const float PI = 3.14159265359;

float D_GGX(float NoH, float roughness) {
    float a = roughness * roughness;
    float a2 = a * a;
    float NoH2 = NoH * NoH;
    float denom = (NoH2 * (a2 - 1.0) + 1.0);
    return a2 / (PI * denom * denom);
}

float V_SmithGGXCorrelated(float NoV, float NoL, float roughness) {
    float a = roughness;
    float GGXV = NoL * (NoV * (1.0 - a) + a);
    float GGXL = NoV * (NoL * (1.0 - a) + a);
    return 0.5 / (GGXV + GGXL);
}

vec3 F_Schlick(float cosTheta, vec3 f0) {
    return f0 + (vec3(1.0) - f0) * pow(clamp(1.0 - cosTheta, 0.0, 1.0), 5.0);
}

vec3 BRDF(vec3 L, vec3 V, vec3 N, vec3 f0, float roughness, vec3 albedo, float metallic) {
    vec3 H = normalize(V + L);
    float NoV = abs(dot(N, V)) + 1e-5;
    float NoL = clamp(dot(N, L), 0.0, 1.0);
    float NoH = clamp(dot(N, H), 0.0, 1.0);
    float LoH = clamp(dot(L, H), 0.0, 1.0);

    float D = D_GGX(NoH, roughness);
    float Vis = V_SmithGGXCorrelated(NoV, NoL, roughness);
    vec3  F = F_Schlick(LoH, f0);

    vec3 specular = D * Vis * F;

    vec3 kD = (vec3(1.0) - F) * (1.0 - metallic);
    vec3 diffuse = kD * albedo / PI;

    return (diffuse + specular) * NoL;
}

// From http://www.decew.net/OSS/References/D3DTutorial10_Half-Life2_Shading.pdf
const vec3 basis0 = vec3(-0.408248, -0.707107, 0.577350);
const vec3 basis1 = vec3(-0.408248,  0.707107, 0.577350);
const vec3 basis2 = vec3( 0.816497,  0.000000, 0.577350);
vec3 CalcRadiosityNormalMapping(vec3 N, vec3 lightColor0, vec3 lightColor1, vec3 lightColor2)
{
    float d0 = max(dot(N, basis0), 0.0);
    float d1 = max(dot(N, basis1), 0.0);
    float d2 = max(dot(N, basis2), 0.0);

    d0 *= d0;
    d1 *= d1;
    d2 *= d2;

    return (d0 * lightColor0) + (d1 * lightColor1) + (d2 * lightColor2);
}